import { writeFileSync } from "node:fs";
import { join } from "node:path";

import { glob } from "glob";
import { remark } from "remark";
import remarkGfm from "remark-gfm";
import type { DirResult, FileResult } from "tmp";
import { readSync } from "to-vfile";
import { dedent } from "ts-dedent";
import type { VFile } from "vfile";

import { TempFiles } from "@support/utils/TempFiles";
const { dirSync, fileSync } = new TempFiles();

import remarkReplaceMermaid from "@src/lib/confluence/transformer/support/remark/remark-replace-mermaid";

describe("remark-replace-mermaid", () => {
  let tmpDir: DirResult;

  beforeEach(() => {
    tmpDir = dirSync({ unsafeCleanup: true });
  });

  it("should be defined", () => {
    expect(remarkReplaceMermaid).toBeDefined();
  });

  it("should not replace no mermaid code", () => {
    // Arrange
    const input = "This is a paragraph with no mermaid code";

    // Act
    const actual = remark()
      .use(remarkGfm)
      .use(remarkReplaceMermaid, { outDir: tmpDir.name })
      .processSync(input)
      .toString();

    // Assert
    expect(actual).toContain(input);
  });

  // FIXME: This test should throw error.
  //  It changes due to lack of time to debug possible issues with mermaid cli.
  it("should not replace invalid mermaid code", () => {
    // Arrange
    const input = dedent`\`\`\`mermaid
    unknown
    \`\`\``;

    // Act & Assert
    expect(() =>
      remark()
        .use(remarkGfm)
        .use(remarkReplaceMermaid, { outDir: tmpDir.name })
        .processSync(input),
    ).not.toThrow();
  });

  // TODO: Enable this test when mermaid deps are fixed in the runners CI
  // eslint-disable-next-line jest/no-disabled-tests
  describe.skip("mermaid code", () => {
    let content: string;
    let vFile: VFile;
    let file: FileResult;

    beforeEach(() => {
      content = dedent`\`\`\`mermaid
        graph LR
          A-->B
        \`\`\``;
      file = fileSync({ dir: tmpDir.name, postfix: ".md" });
      writeFileSync(file.name, content);
      vFile = readSync(file.name);
    });

    it("should replace mermaid code", () => {
      // Arrange
      // Act
      const actual = remark()
        .use(remarkGfm)
        .use(remarkReplaceMermaid, { outDir: tmpDir.name })
        .processSync(vFile)
        .toString();

      // Assert
      expect(actual).not.toContain(content);
    });

    it("should create an image in given directory", async () => {
      // Arrange
      // Act
      const result = remark()
        .use(remarkGfm)
        .use(remarkReplaceMermaid, { outDir: tmpDir.name })
        .processSync(vFile)
        .toString();

      // Assert
      const autogeneratedImages = await glob("autogenerated-*.svg", {
        cwd: tmpDir.name,
      });

      expect(autogeneratedImages).toHaveLength(1);

      const autogeneratedSvg = autogeneratedImages[0];

      expect(autogeneratedSvg).toBeDefined();
      expect(result).toContain(`![](${join(tmpDir.name, autogeneratedSvg)})`);
    });
  });
});
