// SPDX-FileCopyrightText: 2024 Telefónica Innovación Digital
// SPDX-License-Identifier: Apache-2.0

import { unified } from "unified";

import rehypeReplaceImgTags from "@src/lib/confluence/transformer/support/rehype/rehype-replace-img-tags";

describe("rehype-replace-img-tags", () => {
  it("should be defined", () => {
    expect(rehypeReplaceImgTags).toBeDefined();
  });

  it("should not replace img elements without src attribute", async () => {
    const tree = {
      type: "root" as const,
      children: [
        {
          type: "element" as const,
          tagName: "img",
          children: [],
        },
      ],
    };
    const expected = {
      type: "root" as const,
      children: [
        {
          type: "element" as const,
          tagName: "img",
          children: [],
        },
      ],
    };
    const actual = await unified().use(rehypeReplaceImgTags).run(tree);

    expect(actual).toEqual(expected);
  });

  it("should replace <img> elements with Confluence storage image macro", async () => {
    const tree = {
      type: "root" as const,
      children: [
        {
          type: "element" as const,
          tagName: "img",
          properties: {
            src: "https://example.com/image.png",
          },
          children: [],
        },
      ],
    };
    const expected = {
      type: "root" as const,
      children: [
        {
          type: "element" as const,
          tagName: "ac:image",
          children: [
            {
              type: "element" as const,
              tagName: "ri:url",
              properties: {
                "ri:value": "https://example.com/image.png",
              },
              children: [],
            },
          ],
        },
      ],
    };
    const actual = await unified().use(rehypeReplaceImgTags).run(tree);

    expect(actual).toEqual(expected);
  });

  it("should replace <img> elements with Confluence storage image macro for relative paths and not add width property because image doesn't svg", async () => {
    const tree = {
      type: "root" as const,
      children: [
        {
          type: "element" as const,
          tagName: "img",
          properties: {
            src: "image.png",
          },
          children: [],
        },
      ],
    };
    const expected = {
      type: "root" as const,
      children: [
        {
          type: "element" as const,
          tagName: "ac:image",
          properties: {},
          children: [
            {
              type: "element" as const,
              tagName: "ri:attachment",
              properties: {
                "ri:filename": "image.png",
              },
              children: [],
            },
          ],
        },
      ],
    };
    const actual = await unified().use(rehypeReplaceImgTags).run(tree);

    expect(actual).toEqual(expected);
  });

  it("should replace <img> elements with Confluence storage image macro for relative paths and add width property because the image name contains 'autogenerated' and is svg", async () => {
    const tree = {
      type: "root" as const,
      children: [
        {
          type: "element" as const,
          tagName: "img",
          properties: {
            src: "autogenerated-image.svg",
          },
          children: [],
        },
      ],
    };
    const expected = {
      type: "root" as const,
      children: [
        {
          type: "element" as const,
          tagName: "ac:image",
          properties: { "ac:width": "1000" },
          children: [
            {
              type: "element" as const,
              tagName: "ri:attachment",
              properties: {
                "ri:filename": "autogenerated-image.svg",
              },
              children: [],
            },
          ],
        },
      ],
    };
    const actual = await unified().use(rehypeReplaceImgTags).run(tree);

    expect(actual).toEqual(expected);
  });

  it("should replace <img> elements with Confluence storage image macro for relative paths but not add width property because the image name not contains 'autogenerated'", async () => {
    const tree = {
      type: "root" as const,
      children: [
        {
          type: "element" as const,
          tagName: "img",
          properties: {
            src: "image.svg",
          },
          children: [],
        },
      ],
    };
    const expected = {
      type: "root" as const,
      children: [
        {
          type: "element" as const,
          tagName: "ac:image",
          properties: {},
          children: [
            {
              type: "element" as const,
              tagName: "ri:attachment",
              properties: {
                "ri:filename": "image.svg",
              },
              children: [],
            },
          ],
        },
      ],
    };
    const actual = await unified().use(rehypeReplaceImgTags).run(tree);

    expect(actual).toEqual(expected);
  });
});
